---
title: "Example workflow of scABC"
author: "Timothy Daley"
date: "4/30/2017"
output: html_document
---

We're going to walk through an example workflow for the scABC package, walking through all the individual steps of the analysis.  We'll use the 6 cell line mixture for an example.  The 1632 cells can be downloaded from GEO under accession number GSE65360 (https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE65360).  

## Pre-processing

We used Kundaje pipeline for aligning pair ended reads to hg19 and removing duplicates (https://github.com/kundajelab/atac_dnase_pipelines) with the command below for each read pair file.
```{r engine='bash', eval=FALSE}
bds_scr [SCR_NAME] atac.bds -align -species hg19 -species_file [SPECIES_FILE_PATH] -nth [NUM_THREADS] -fastq1_1 [READ_PAIR1] -fastq1_2 [READ_PAIR2]
```
For details on the pipeline, visit the Kundaje lab website or github page.

The resulting bam files were merged using samtools.
```{r engine='bash', eval=FALSE}
samtools merge [AGGREGATE_BAM] *.trim.PE2SE.nodup.bam
```
The merged bam file was then used as input into MACS2 to call merged peaks for later analysis, using the Kundaje pipeline again.
```{r engine='bash', eval=FALSE}
bds_scr [SCR_NAME] atac.bds -species hg19 -species_file [SPECIES_FILE_PATH] -nth [NUM_THREADS] -se -filt_bam [AGGREGATE_BAM]
```

Several of the cells have multiple runs.  We merged these runs using samtools.

## Obtaining and filtering counts

We will use scABC to analyse the single cell data.  The cell level bam files and their samtools indexes are contained in the folder bams.
```{r}
setwd("~/scRNAseqAnalysis/scATAC-RNAseq/scABC/vignettes/")
library(devtools)
devtools::install_github("timydaley/scABC", force = TRUE)
library(scABC)
# table that has experiment info
bamfile.table = read.table(file = "NoTreatment/6Lines/SRX&Type&Batch.txt")
head(bamfile.table)
bamfiles = paste0("bams/", bamfile.table[,1], ".bam")
peaks = select_peaks("NoTreatment/6Lines/mergeAll.tn5.pf.gappedPeak")
dim(peaks)
```

Computing the Forground and Background matrix takes quite a bit of time.  We can do this once and cache the results for later.

```{r cache=TRUE}
ForeGround = get_counts_matrix(bamfiles, peaks);
```

```{r cache=TRUE}
ForeGroundFiltered = filter_peaks(ForeGround$ForeGroundMatrix, peaks)
peaks = ForeGroundFiltered$peaks
```

```{r cache=TRUE}
BackGround = get_background(bamfiles, peaks)
ForeGroundBackGroundFiltered = filter_samples(ForeGround = ForeGroundFiltered$ForeGroundMatrix, BackGround = BackGround$BackGroundMatrix)
InSilicoForeGround = ForeGroundBackGroundFiltered$ForeGroundMatrix
InSilicoBackGround = ForeGroundBackGroundFiltered$BackGroundMatrix
InSilicoPeaks = peaks
```

Now let's compute the landmarks and take a look at them.

```{r message=FALSE, cache=TRUE}
InSilicoLandMarks = compute_landmarks(ForeGround = InSilicoForeGround, 
                                      BackGround = InSilicoBackGround, 
                                      nCluster = 6, lambda = 1, nTop = 2000)
# look at correlation between landmarks
cor(InSilicoLandMarks, InSilicoLandMarks, method = 'spearman')
```

It looks like the cluster landmarks are well seperated.  Let's look at the cell to cluster assignments.

```{r cache=TRUE}
# assign cells to the closest landmark
InSilicoLandMarkAssignments = assign2landmarks(InSilicoForeGround, InSilicoLandMarks)
InSilicoCell2LandmarkCorrelation = cbind(apply(InSilicoForeGround, 2, function(x) cor(x, InSilicoLandMarks[,1], method = 'spearman')), 
                                         apply(InSilicoForeGround, 2, function(x) cor(x, InSilicoLandMarks[,2], method = 'spearman')), 
                                         apply(InSilicoForeGround, 2, function(x) cor(x, InSilicoLandMarks[,3], method = 'spearman')), 
                                         apply(InSilicoForeGround, 2, function(x) cor(x, InSilicoLandMarks[,4], method = 'spearman')), 
                                         apply(InSilicoForeGround, 2, function(x) cor(x, InSilicoLandMarks[,5], method = 'spearman')), 
                                         apply(InSilicoForeGround, 2, function(x) cor(x, InSilicoLandMarks[,6], method = 'spearman')))
cell.info = bamfile.table[which(paste0(bamfile.table[,1], ".bam") %in% colnames(InSilicoForeGround)), 2]
library(gplots) 
library(RColorBrewer)
library(devtools)
source_url("https://raw.githubusercontent.com/obigriffith/biostar-tutorials/master/Heatmaps/heatmap.3.R")
scalered <- colorRampPalette(c("white", "red"), space = "rgb")(256)
rcols1 = brewer.pal(6, "Accent")[1:6]
rowcols1 = rcols1[cell.info]
rcols2 = brewer.pal(6, "Dark2")[1:6]
rowcols2 = rcols2[InSilicoLandMarkAssignments]
rowcols = rbind(rowcols1, rowcols2)
rownames(rowcols) = c("rep info", "cluster")
heatmap.3(InSilicoCell2LandmarkCorrelation, dendrogram='none', Rowv=FALSE, Colv=FALSE, trace='none', col = scalered, margin = c(5, 5), density.info = "none", RowSideColors = rowcols, RowSideColorsSize=2, symm=F,symkey=F,symbreaks=F, scale="none")
legend("bottomleft", legend = c(unique(cell.info), paste0("cluster ", 1:6)), col = c(rcols1, rcols2), border=FALSE, bty="n", y.intersp = 0.7, cex=0.7, pch = 15)
heatmap.2(InSilicoCell2LandmarkCorrelation, dendrogram='none', Rowv=FALSE, Colv=FALSE, trace='none', col = scalered, margin = c(5, 5), density.info = "none", RowSideColors = rowcols1, symm=F,symkey=F,symbreaks=F, scale="none")
legend("bottomleft", legend = c(unique(cell.info)), col = rcols1, border=FALSE, bty="n", y.intersp = 0.7, cex=0.7, pch = 15)
```

To view the above figure better, we're normalize the correlations of each cell so that the maximum is 1.

```{r cache=TRUE}
for(i in 1:dim(InSilicoCell2LandmarkCorrelation)[1]){
  InSilicoCell2LandmarkCorrelation[i,] = InSilicoCell2LandmarkCorrelation[i,]/mean(InSilicoCell2LandmarkCorrelation[i,])
}
library(gplots) 
library(RColorBrewer)
heatmap.2(InSilicoCell2LandmarkCorrelation, dendrogram='none', Rowv=FALSE, Colv=FALSE, trace='none', col = scalered, margin = c(5, 5), density.info = "none", RowSideColors = rowcols1, symm=F,symkey=F,symbreaks=F, scale="none")
legend("bottomleft", legend = c(unique(cell.info)), col = rcols1, border=FALSE, bty="n", y.intersp = 0.7, cex=0.7, pch = 15)
```

The clustering correctly classifies all cells except for 1.  This assumes we knew the number of clusters.  What if we let scABC choose the number of clusters?

```{r message=FALSE, cache=TRUE}
InSilicoBackGroundMedian = apply(InSilicoBackGround, 2, median)
InSilicoGapStat = getGapStat(InSilicoForeGround, InSilicoBackGroundMedian, nClusters=1:10, nPerm = 20, quiet = TRUE)
InSilicoGapStat$nClusterOptimal
plotGapStat(InSilicoGapStat, nClusters = 1:10, main = "In Silico Gap Stat")
```

scABC chooses 6 clusters and we can continue with this number of clusters.

```{r cache=TRUE}
InSilicoPeakSelection = getClusterSpecificPvalue(ForeGround=InSilicoForeGround, cluster_assignments = InSilicoLandMarkAssignments, background_medians = InSilicoBackGroundMedian)
InSilicoPeakPvals = InSilicoPeakSelection$pvalue
head(InSilicoPeakPvals)
```

Let's visualize the data.

```{r cache=TRUE}
# all peaks 
scalered <- colorRampPalette(c("white", "red"), space = "rgb")(256)
rcols1 = brewer.pal(6, "Accent")[1:6]
rowcols1 = rcols1[cell.info]
rcols2 = brewer.pal(6, "Dark2")[1:6]
rowcols2 = rcols2[InSilicoLandMarkAssignments]
rowcols = rbind(rowcols1, rowcols2)
rownames(rowcols) = c("rep info", "cluster")
x = t(InSilicoForeGround)
x = x[ ,head(order(rowSums(InSilicoForeGround), decreasing = TRUE), 10000)]
d = as.dist(1 - cor(x, method = "spearman"))
col.clus = hclust(d, method ="average")
#truncate to see patterns
x[which(x > 5)] = 5
heatmap.3(x, dendrogram='none', Rowv=FALSE, Colv=col.clus, trace='none', col = scalered, margin = c(5, 5), density.info = "none", RowSideColors = rowcols, RowSideColorsSize=2, main = "All peaks")
legend("bottomleft", legend = c(unique(cell.info), paste0("cluster ", 1:6)), col = c(rcols1, rcols2), border=FALSE, bty="n", y.intersp = 0.7, cex=0.7, pch = 15)
```
```{r cache=TRUE}
# cluster specific peaks
ClusterSpecificPeaks = head(order(apply(InSilicoPeakPvals, 1, min), decreasing = FALSE), 10000)
length(ClusterSpecificPeaks)
x = t(InSilicoForeGround[ClusterSpecificPeaks, ])
d = as.dist(1 - cor(x, method = "spearman"))
col.clus = hclust(d, method ="average")
#truncate to see patterns
x[which(x > 5)] = 5
heatmap.3(x, dendrogram='none', Rowv=FALSE, Colv=as.dendrogram(col.clus), trace='none', col = scalered, margin = c(5, 5), density.info = "none", RowSideColors = rowcols, RowSideColorsSize=2, main = "Cluster specific peaks")
legend("bottomleft", legend = c(unique(cell.info), paste0("cluster ", 1:6)), col = c(rcols1, rcols2), border=FALSE, bty="n", y.intersp = 0.7, cex=0.7, pch = 15)
```

Instead of all of the above commands to obtain the clustered and processed data, we can simply use the scABC command to do all of the above.

```{r cache=TRUE}
source("~/scRNAseqAnalysis/scATAC-RNAseq/scABC/R/scABC.R")
library(GenomicRanges)
library(Rsamtools)
library(WeightedCluster)
peakfile = "NoTreatment/6Lines/mergeAll.tn5.pf.gappedPeak"
bamfile.table = read.table(file = "NoTreatment/6Lines/SRX&Type&Batch.txt")
bamfiles = paste0("bams/", bamfile.table[,1], ".bam")
InSilicoSCABC = scABC(bamfiles, peakfile)
ClusterSpecificPeaksV2 = head(order(apply(InSilicoSCABC$PeakPVals, 1, min), decreasing = FALSE), 10000)
length(intersect(ClusterSpecificPeaks, ClusterSpecificPeaksV2))
```

```{r cache=TRUE}
# all peaks are cluster specific
scalered <- colorRampPalette(c("white", "red"), space = "rgb")(256)
rcols1 = brewer.pal(6, "Accent")[1:6]
rowcols1 = rcols1[cell.info]
rcols2 = brewer.pal(6, "Dark2")[1:6]
rowcols2 = rcols2[InSilicoSCABC$cluster_assignments]
rowcols = rbind(rowcols1, rowcols2)
rownames(rowcols) = c("rep info", "cluster")
x = t(InSilicoSCABC$ForeGroundMatrix[ClusterSpecificPeaksV2, ])
d = as.dist(1 - cor(x, method = "spearman"))
col.clus = hclust(d, method ="average")
x[which(x > 5)] = 5
heatmap.3(x, dendrogram='none', Rowv=FALSE, Colv=as.dendrogram(col.clus), trace='none', col = scalered, margin = c(5, 5), density.info = "none", RowSideColors = rowcols, RowSideColorsSize=2, main = "Cluster specific peaks")
legend("bottomleft", legend = c(unique(cell.info), paste0("cluster ", 1:6)), col = c(rcols1, rcols2), border=FALSE, bty="n", y.intersp = 0.7, cex=0.7, pch = 15)
```